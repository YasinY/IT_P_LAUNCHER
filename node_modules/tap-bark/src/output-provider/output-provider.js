"use strict";
var result_type_1 = require("../result-type");
var chalk = require("chalk");
var OutputProvider = (function () {
    function OutputProvider() {
    }
    OutputProvider.prototype.getResultMessage = function (type, typeCount, totalCount) {
        switch (type) {
            case result_type_1.ResultType.PASS:
                return chalk.green("Pass: " + typeCount + "/" + totalCount);
            case result_type_1.ResultType.FAIL:
                return chalk.red("Fail: " + typeCount + "/" + totalCount);
            case result_type_1.ResultType.IGNORE:
                return chalk.yellow("Ignore: " + typeCount + "/" + totalCount);
        }
        throw new TypeError("Invalid ResultType.");
    };
    OutputProvider.prototype.getTestFixtureMessage = function (name) {
        return "# [" + name + "]";
    };
    OutputProvider.prototype.getTestMessage = function (name) {
        return " --- " + name;
    };
    OutputProvider.prototype.getFailureMessage = function (assertion) {
        var failureTitle = chalk.red("FAIL: ") + chalk.bold(assertion.name) + "\n";
        if (assertion.diag) {
            var output = failureTitle + assertion.diag.message + "\nExpected: " + assertion.diag.data.expect + "\n  Actual: " + assertion.diag.data.got;
            if (assertion.diag.data.stack) {
                output = output
                    + "\n=====\n"
                    + chalk.bold.white("Stack Trace") + "\n\n"
                    + assertion.diag.data.stack + "\n"
                    + "=====";
            }
            return output;
        }
        return failureTitle + "Failure reason unknown.";
    };
    return OutputProvider;
}());
exports.OutputProvider = OutputProvider;
