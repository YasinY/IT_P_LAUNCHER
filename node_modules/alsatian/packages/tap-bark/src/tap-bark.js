"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = require("chalk");
var through = require("through2");
var parser = require("tap-parser");
var duplexer = require("duplexer");
var _a = require("ink"), h = _a.h, render = _a.render, Component = _a.Component, Color = _a.Color, Indent = _a.Indent;
exports.Component = Component;
var TAP_PARSER = parser();
var TapBarkOutput = (function (_super) {
    __extends(TapBarkOutput, _super);
    function TapBarkOutput(props) {
        var _this = _super.call(this, props) || this;
        _this.FIXTURE_REGEXP = /^# FIXTURE (.*)/;
        _this.CONSOLE_WARNING_REGEXP = /^# WARN: (.*)/;
        _this._completeCalled = false;
        _this.warnings = [];
        _this.state = {
            logs: [],
            warnings: []
        };
        _this.setupListeners();
        return _this;
    }
    TapBarkOutput.prototype.getPipeable = function () {
        return duplexer(TAP_PARSER, through());
    };
    TapBarkOutput.prototype.getFailureMessage = function (assertion) {
        var failureTitle = chalk_1.default.red("FAIL: ") + chalk_1.default.bold(assertion.name) + "\n";
        if (assertion.diag) {
            var data = assertion.diag.data;
            var details_1 = data.details;
            var title = failureTitle + " " + assertion.diag.message + "\n";
            if (details_1 && Object.keys(details_1).length > 0) {
                return "" + title + Object.keys(details_1)
                    .map(function (key) { return "\n" + chalk_1.default.underline(key) + ":\n" + details_1[key]; })
                    .join("\n");
            }
            return title + "\nexpected:\n" + data.expect + "\nactual:\n" + data.got;
        }
        return failureTitle + "Failure reason unknown.";
    };
    TapBarkOutput.prototype.render = function () {
        var results = this.state.results;
        var total = this.state.totalTests;
        if (this.state.results) {
            return h(Indent, null,
                this.state.warnings.join("\n"),
                h(Color, { green: true },
                    "Pass: ",
                    results.pass,
                    " / ",
                    total,
                    "\n"),
                h(Color, { red: true },
                    "Fail: ",
                    results.fail,
                    " / ",
                    total,
                    "\n"),
                h(Color, { yellow: true },
                    "Ignore: ",
                    results.ignore,
                    " / ",
                    total,
                    "\n",
                    "\n"),
                results.failures.map(this.getFailureMessage.bind(this)).join("\n"));
        }
        if (this.props.showProgress === false) {
            return h(Indent, null, "running alsatian tests");
        }
        return h(Indent, null,
            Math.floor(this.state.currentTest / total * 100 || 0),
            "% complete");
    };
    TapBarkOutput.prototype.handleNewPlan = function (plan) {
        this.setState({
            totalTests: plan.end
        });
    };
    TapBarkOutput.prototype.handleComment = function (comment) {
        var fixtureParse = this.FIXTURE_REGEXP.exec(comment);
        if (fixtureParse !== null) {
            this.setState({
                fixtureName: fixtureParse[1]
            });
        }
        else {
            var message = comment.replace("# ", "");
            if (this.CONSOLE_WARNING_REGEXP.test(comment)) {
                this.warnings.push(chalk_1.default.yellow(message));
                this.setState({
                    warnings: this.warnings
                });
            }
        }
    };
    TapBarkOutput.prototype.handleAssert = function (assertion) {
        this.setState({
            currentTest: assertion.id,
            testName: assertion.name
        });
    };
    TapBarkOutput.prototype.handleComplete = function (results) {
        var _results = {
            pass: results.pass || 0,
            fail: (results.fail || (results.failures || []).length),
            ignore: (results.skip || 0) + (results.todo || 0),
            failures: results.failures || []
        };
        if (this._completeCalled === false) {
            this._completeCalled = true;
            this.setState(__assign({}, this.state, { results: _results }), setTimeout(function () {
                if (results.ok) {
                    process.exit(0);
                }
                else {
                    process.exit(1);
                }
            }, 100));
        }
    };
    TapBarkOutput.prototype.setupListeners = function () {
        if (this.props.showProgress) {
            TAP_PARSER.on("comment", this.handleComment.bind(this));
            TAP_PARSER.on("assert", this.handleAssert.bind(this));
        }
        TAP_PARSER.on("plan", this.handleNewPlan.bind(this));
        TAP_PARSER.on("complete", this.handleComplete.bind(this));
    };
    return TapBarkOutput;
}(Component));
exports.TapBarkOutput = TapBarkOutput;
var TapBark = (function () {
    function TapBark() {
    }
    TapBark.create = function (showProgress) {
        if (showProgress === void 0) { showProgress = true; }
        var tapBarkOutput = h(TapBarkOutput, { showProgress: showProgress });
        render(tapBarkOutput);
        return tapBarkOutput.instance;
    };
    TapBark.tapParser = TAP_PARSER;
    return TapBark;
}());
exports.TapBark = TapBark;
